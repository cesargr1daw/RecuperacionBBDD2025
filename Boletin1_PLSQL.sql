/*ALTER SESSION SET "_ORACLE_SCRIPT"=TRUE;  
CREATE USER recuperacion_11Junio IDENTIFIED BY recuperacion_11Junio;
GRANT CONNECT, RESOURCE, DBA TO recuperacion_11Junio;*/

CREATE TABLE TIPO_PIEZA(
	TIPO VARCHAR2(2),
	DESCRIPCION VARCHAR2(25),
	CONSTRAINT PK_TIPO_PIEZA PRIMARY KEY(TIPO)
);

CREATE TABLE PIEZA(
	MODELO NUMBER(2),
	TIPO VARCHAR2(2),
	PRECIO_VENTA NUMBER(11,4),
	CONSTRAINT PK_PIEZA PRIMARY KEY(MODELO, TIPO),
	CONSTRAINT FK_PIEZA_TIPO FOREIGN KEY (TIPO) REFERENCES TIPO_PIEZA(TIPO)
);

CREATE TABLE EMPRESA(
	CIF VARCHAR2(9),
	NOMBRE VARCHAR2(50),
	TELEFONO NUMBER(9),
	DIRECCION VARCHAR2(50),
	LOCALIDAD VARCHAR2(50),
	PROVINCIA VARCHAR2(50),
	CONSTRAINT PK_EMPRESA PRIMARY KEY(CIF)
);

CREATE TABLE SUMINISTRO(
    CIF VARCHAR2(9), 
    MODELO NUMBER(2),
    TIPO VARCHAR2(2),
    PRECIO_COMPRA NUMBER(11,4),
    CONSTRAINT PK_SUMINISTRO PRIMARY KEY(CIF, MODELO, TIPO),
    CONSTRAINT FK_EMPRESA_SUMINISTRO FOREIGN KEY (CIF) REFERENCES EMPRESA(CIF),
    CONSTRAINT FK_PIEZA_SUMINISTRO FOREIGN KEY (MODELO, TIPO) REFERENCES PIEZA(MODELO, TIPO)
);


CREATE TABLE ALMACEN(
	N_ALMACEN NUMBER(2),
	DESCRIPCION VARCHAR2(100),
	DIRECCION VARCHAR2(100),
	CONSTRAINT PK_ALMACEN PRIMARY KEY(N_ALMACEN)
);

CREATE TABLE EXISTENCIA(
    MODELO NUMBER(2),
    TIPO VARCHAR2(2),
    N_ALMACEN NUMBER(2),
    CANTIDAD NUMBER(9),
    CONSTRAINT PK_EXISTENCIA PRIMARY KEY(MODELO, TIPO, N_ALMACEN),
    CONSTRAINT FK_PIEZA_EXISTENCIA FOREIGN KEY (MODELO, TIPO) REFERENCES PIEZA(MODELO, TIPO),
    CONSTRAINT FK_ALMACEN_EXISTENCIA FOREIGN KEY (N_ALMACEN) REFERENCES ALMACEN(N_ALMACEN)
);

CREATE TABLE DEPARTAMENTO(
	NUM_DEP NUMBER(3),
	NOMBRE VARCHAR2(50),
	CONSTRAINT PK_DEPARTAMENTO PRIMARY KEY(NUM_DEP)
);

CREATE TABLE EMPLEADO(
	EMP_NO NUMBER(3),
	APELLIDO VARCHAR2(50),
	SALARIO NUMBER(6,2),
	OFICIO VARCHAR2(50),
	FECHA_ALTA DATE,
	N_ALMACEN NUMBER(2),
	NUM_DEP NUMBER(3),
	CONSTRAINT PK_EMPLEADO PRIMARY KEY(EMP_NO),
	CONSTRAINT FK_ALMACEN_EMPLEADO FOREIGN KEY (N_ALMACEN) REFERENCES ALMACEN(N_ALMACEN),
	CONSTRAINT FK_DEPARTAMENTO_EMPLEADO FOREIGN KEY (NUM_DEP) REFERENCES DEPARTAMENTO(NUM_DEP)
);

-- Datos ejemplo
-- Insertar en TIPO_PIEZA
INSERT INTO TIPO_PIEZA VALUES ('TP', 'Tipo Prueba');
INSERT INTO TIPO_PIEZA VALUES ('MR', 'Motor');

-- Insertar en PIEZA
INSERT INTO PIEZA VALUES (1, 'TP', 150.75);
INSERT INTO PIEZA VALUES (2, 'MR', 240.99);

-- Insertar en EMPRESA
INSERT INTO EMPRESA VALUES ('A12345678', 'Suministros Lopez', 98765432, 'Calle 1', 'Madrid', 'Madrid');
INSERT INTO EMPRESA VALUES ('B87654321', 'Componentes S.A.', 98765431, 'Calle 2', 'Sevilla', 'Sevilla');

-- Insertar en SUMINISTRO
INSERT INTO SUMINISTRO VALUES ('A12345678', 1, 'TP', 120.50);
INSERT INTO SUMINISTRO VALUES ('B87654321', 2, 'MR', 200.00);

-- Insertar en ALMACEN
INSERT INTO ALMACEN VALUES (1, 'Almacén Central', 'Av. Gran Vía, 101');
INSERT INTO ALMACEN VALUES (2, 'Almacén Norte', 'Calle Norte, 55');

-- Insertar en EXISTENCIA
INSERT INTO EXISTENCIA VALUES (1, 'TP', 1, 100);
INSERT INTO EXISTENCIA VALUES (2, 'MR', 2, 200);

-- Insertar en DEPARTAMENTO
INSERT INTO DEPARTAMENTO VALUES (10, 'Ventas');
INSERT INTO DEPARTAMENTO VALUES (20, 'Logística');

-- Insertar en EMPLEADO
INSERT INTO EMPLEADO VALUES (127, 'Gomez', 1500.00, 'VENDEDOR', SYSDATE, 1, 10);
INSERT INTO EMPLEADO VALUES (128, 'Perez', 1800.00, 'ALMACENERO', TO_DATE('2023-05-10', 'YYYY-MM-DD'), 2, 20);
INSERT INTO EMPLEADO VALUES (129, 'Lopez', 2500.00, 'PRESIDENTE', TO_DATE('2022-01-01', 'YYYY-MM-DD'), 1, 10);

-- EJERCICIO 1
--APARTADO A
BEGIN FOR emp IN (SELECT APELLIDO, OFICIO FROM EMPLEADO WHERE EMPLEADO.EMP_NO =127)
	LOOP
		DBMS_OUTPUT.PUT_LINE('APELLIDO: '||emp.APELLIDO||' OFICIO: '||emp.OFICIO);
	END LOOP;
END;

--APARTADO B
BEGIN FOR emp IN (SELECT EMPLEADO.APELLIDO, EMPLEADO.OFICIO FROM EMPLEADO WHERE EMPLEADO.NUM_DEP=20)
	LOOP 
		DBMS_OUTPUT.PUT_LINE('APELLIDO: '|| emp.APELLIDO);
	END LOOP;
END;

-- EJERCICIO 2
DECLARE
	CURSOR c_empleado IS
		SELECT apellido, fecha_alta
		FROM empleado
		ORDER BY fecha_alta;
BEGIN
	FOR emp IN c_empleado LOOP
		DBMS_OUTPUT.PUT_LINE(emp.apellido || ' - ' || TO_CHAR(emp.fecha_alta, 'DD-MM-YYYY'));
	END LOOP;
END;

-- EJERCICIO 3
/*CREATE OR REPLACE TRIGGER TR_SUELDOS_EMPLEADOS IS 
BEFORE INSERT OR UPDATE ON EMPLEADO 
FOR EACH ROW*/
	
-- EJERCICIO 4

CREATE OR REPLACE TRIGGER TR_UPDATE_PIEZA
AFTER UPDATE ON TIPO_PIEZA
FOR EACH ROW
BEGIN
	UPDATE PIEZA
	SET TIPO = :NEW.TIPO
	WHERE TIPO = :OLD.TIPO;
END;

CREATE OR REPLACE TRIGGER TR_UPDATE_EXISTENCIA
AFTER UPDATE ON TIPO_PIEZA
FOR EACH ROW
BEGIN
	UPDATE EXISTENCIA
	SET TIPO = :NEW.TIPO
	WHERE TIPO = :OLD.TIPO;
END;

CREATE OR REPLACE TRIGGER TR_UPDATE_SUMINISTRO
AFTER UPDATE ON TIPO_PIEZA
FOR EACH ROW
BEGIN
	UPDATE SUMINISTRO
	SET TIPO = :NEW.TIPO
	WHERE TIPO = :OLD.TIPO;
END;

--PRE ACTUALIZACION:
SELECT * FROM PIEZA WHERE TIPO LIKE 'TP_NEW';
SELECT * FROM EXISTENCIA WHERE TIPO LIKE 'TP_NEW';
SELECT * FROM SUMINISTRO WHERE TIPO LIKE 'TP_NEW';
SELECT * FROM PIEZA WHERE TIPO LIKE 'TP';
SELECT * FROM EXISTENCIA WHERE TIPO LIKE 'TP';
SELECT * FROM SUMINISTRO WHERE TIPO LIKE 'TP';

UPDATE TIPO_PIEZA SET TIPO_PIEZA.TIPO = 'TP_NEW' WHERE TIPO_PIEZA.TIPO = 'TP';

--POST ACTUALIZACION
SELECT * FROM PIEZA WHERE TIPO LIKE 'TP_NEW';
SELECT * FROM EXISTENCIA WHERE TIPO LIKE 'TP_NEW';
SELECT * FROM SUMINISTRO WHERE TIPO LIKE 'TP_NEW';
SELECT * FROM PIEZA WHERE TIPO LIKE 'TP';
SELECT * FROM EXISTENCIA WHERE TIPO LIKE 'TP';
SELECT * FROM SUMINISTRO WHERE TIPO LIKE 'TP';



-- EJERCICIO 5
CREATE TABLE SUMINISTROS_AUDIT (
	TIPO VARCHAR2(2),
	MODELO NUMBER(2),
	CIF VARCHAR2(9),
	PRECIO_VIEJO NUMBER(11,4),
	PRECIO_NUEVO NUMBER(11,4),
	FECHA DATE
);

CREATE OR REPLACE TRIGGER TR_AUDIT_SUMINISTRO
AFTER UPDATE ON SUMINISTRO
FOR EACH ROW
BEGIN
	INSERT INTO SUMINISTROS_AUDIT (TIPO, MODELO, CIF, PRECIO_VIEJO, PRECIO_NUEVO, FECHA)
	VALUES (:OLD.TIPO, :OLD.MODELO, :OLD.CIF, :OLD.PRECIO_COMPRA, :NEW.PRECIO_COMPRA, SYSDATE);
END;

-- Suponiendo que se cambia el precio de un suministro
UPDATE SUMINISTRO
SET PRECIO_COMPRA = 150.00
WHERE CIF = 'A12345678' AND MODELO = 1 AND TIPO = 'TP';

SELECT * FROM SUMINISTROS_AUDIT sa ;


-- EJERCICIO 6
CREATE OR REPLACE TRIGGER TR_VALIDAR_PRECIO_VENTA
BEFORE UPDATE ON PIEZA
FOR EACH ROW
DECLARE
	v_precio_compra NUMBER(11,4);
BEGIN
	SELECT PRECIO_COMPRA INTO v_precio_compra
	FROM SUMINISTRO
	WHERE CIF = :NEW.CIF AND MODELO = :NEW.MODELO AND TIPO = :NEW.TIPO;

	IF :NEW.PRECIO_VENTA < v_precio_compra THEN
		RAISE_APPLICATION_ERROR(-20002, 'El precio de venta no puede ser menor que el precio de compra.');
	END IF;
END;

--EJERCICIO 7
CREATE OR REPLACE PROCEDURE VER_APELLIDOS_DEPARTAMENTO(v_num_dep NUMBER) IS
BEGIN
	FOR emp IN (SELECT APELLIDO FROM EMPLEADO WHERE NUM_DEP = v_num_dep) 
	LOOP
		DBMS_OUTPUT.PUT_LINE('Apellido: ' || emp.APELLIDO);
	END LOOP;
END;

--EJERCICIO 8
BEGIN
	FOR emp IN (SELECT apellido, fecha_alta
				FROM empleado
				ORDER BY fecha_alta) 
	LOOP
		DBMS_OUTPUT.PUT_LINE(emp.apellido || ' - ' || TO_CHAR(emp.fecha_alta, 'DD-MM-YYYY'));
	END LOOP;
END;

--EJERCICIO 9
CREATE OR REPLACE FUNCTION f_gestionar_empleado(
    V_APELLIDO_EMP EMPLEADO.APELLIDO%TYPE,
    V_ACCION NUMBER
) RETURN NUMBER IS
	v_valor NUMBER(1);
BEGIN
	IF V_ACCION = 1 THEN
		INSERT INTO EMPLEADO (EMP_NO, APELLIDO, SALARIO, OFICIO, FECHA_ALTA, N_ALMACEN, NUM_DEP)
		VALUES ((SELECT NVL(MAX(EMP_NO), 0) + 1 FROM EMPLEADO), V_APELLIDO_EMP, 1500, 'NUEVO', SYSDATE, 1, 10);
		RETURN 1;
	ELSIF V_ACCION = 2 THEN
		DELETE FROM EMPLEADO WHERE APELLIDO = V_APELLIDO_EMP;
		IF SQL%ROWCOUNT > 0 THEN
			RETURN 1;
		ELSE
			RETURN 0;
		END IF;
	ELSE
		RETURN 0;
	END IF;
END f_gestionar_empleado;

DECLARE
	v_resultado NUMBER;
BEGIN
	-- Caso 1: Insertar un nuevo empleado
	v_resultado := f_gestionar_empleado('Martínez', 1);
	DBMS_OUTPUT.PUT_LINE(v_resultado);

	-- Caso 2: Intentar eliminar un empleado existente
	v_resultado := f_gestionar_empleado('Martínez', 2);
	DBMS_OUTPUT.PUT_LINE(v_resultado);

	-- Caso 3: Intentar eliminar un empleado que no existe
	v_resultado := f_gestionar_empleado('ApellidoFicticio', 2);
	DBMS_OUTPUT.PUT_LINE(v_resultado);

	-- Caso 4: Accion inválida
	v_resultado := f_gestionar_empleado('Martínez', 3);
	DBMS_OUTPUT.PUT_LINE(v_resultado);
END;

--EJERCICIO 10
ALTER TABLE DEPARTAMENTO ADD totalempleados NUMBER(3) DEFAULT 0;

UPDATE DEPARTAMENTO d
SET totalempleados = (SELECT COUNT(*) FROM EMPLEADO e WHERE e.NUM_DEP = d.NUM_DEP);

CREATE OR REPLACE TRIGGER TR_UPDATE_TOTAL_EMPLEADOS
AFTER INSERT OR DELETE ON EMPLEADO
FOR EACH ROW
BEGIN
	IF INSERTING THEN
		UPDATE DEPARTAMENTO
		SET totalempleados = totalempleados + 1
		WHERE NUM_DEP = :NEW.NUM_DEP;
	ELSIF DELETING THEN
		UPDATE DEPARTAMENTO
		SET totalempleados = totalempleados - 1
		WHERE NUM_DEP = :OLD.NUM_DEP;
	END IF;
END;

DECLARE
	v_total_empleados NUMBER;
BEGIN
	SELECT totalempleados INTO v_total_empleados FROM DEPARTAMENTO WHERE NUM_DEP = 10;
	DBMS_OUTPUT.PUT_LINE('Total empleados antes de la inserción: ' || v_total_empleados);

	INSERT INTO EMPLEADO (EMP_NO, APELLIDO, SALARIO, OFICIO, FECHA_ALTA, N_ALMACEN, NUM_DEP)
	VALUES ((SELECT NVL(MAX(EMP_NO), 0) + 1 FROM EMPLEADO), 'NUEVO', 1500, 'OPERARIO', SYSDATE, 1, 10);

	SELECT totalempleados INTO v_total_empleados FROM DEPARTAMENTO WHERE NUM_DEP = 10;
	DBMS_OUTPUT.PUT_LINE('Total empleados después de la inserción: ' || v_total_empleados);

	DELETE FROM EMPLEADO WHERE APELLIDO = 'NUEVO' AND NUM_DEP = 10;

	SELECT totalempleados INTO v_total_empleados FROM DEPARTAMENTO WHERE NUM_DEP = 10;
	DBMS_OUTPUT.PUT_LINE('Total empleados después de la eliminación: ' || v_total_empleados);
END;

--EJERCICIO 11
CREATE OR REPLACE PROCEDURE pr_mostrar_letras (v_n NUMBER, v_letra1 CHAR, v_letra2 CHAR) IS 
BEGIN
	IF v_n<=0 THEN 
		DBMS_OUTPUT.PUT_LINE('ERROR: El número debe ser entero y positivo');
		RETURN;
	END IF;
	IF v_letra1 = v_letra2 
		THEN DBMS_OUTPUT.PUT_LINE('ERROR: El número debe ser entero y positivo');
		RETURN;
	END IF;
	FOR i IN 1..v_n LOOP
        FOR j IN 1..v_n LOOP
            DBMS_OUTPUT.PUT(v_letra1);
        END LOOP;
        DBMS_OUTPUT.NEW_LINE;
        
        FOR j IN 1..v_n LOOP
            DBMS_OUTPUT.PUT(v_letra2);
        END LOOP;
        DBMS_OUTPUT.NEW_LINE;
    END LOOP;
END;

BEGIN
    pr_mostrar_letras(6, 'A', 'B'); -- Debería imprimir el patrón con 6 filas
    pr_mostrar_letras(5, 'A', 'B'); -- Debería imprimir el patrón con 5 filas
    pr_mostrar_letras(-3, 'A', 'B'); -- Debería mostrar error
    pr_mostrar_letras(4, 'C', 'C'); -- Debería mostrar error
END;






















